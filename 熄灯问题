/*
@问题： 熄灯问题
	有一个由按钮组成的矩阵，每行共6个按钮，共5行
	每个按钮的位置上有一盏灯
	当按下一个按钮后，该按钮及其周围位置（上下左右）的灯都会改变状态
	给定矩阵中每盏灯的初始状态，求一种按钮方案，使得所有的灯都熄灭
@样例输入：
    1 
	0 1 1 0 1 0
	1 0 0 1 1 1 
	0 0 1 0 0 1
	1 0 0 1 0 1
	0 1 1 1 0 0 
@样例输出
    PUZZLE #1
	1 0 1 0 0 1
	1 1 0 1 0 1
	0 0 1 0 1 1
	1 0 0 1 0 0 
	0 1 0 0 0 0
*/
#include <memory>
#include <string>
#include <cstring>
#include <iostream>
using namespace std;
char oriLights[5];
char lights[5];
char result[5];

int GetBit(char c,int i)
{
	return (c>>i)&1;
}
void SetBit(char &c,int i,int v)
{
	if(v){
		c|=(1<<i);
	}
	else
	    c&=~(1<<i);
}
void FlipBit(char & c,int i)
{
	c^=(1<<i);
}
void OutputResult(int t,char result[])
{
	cout<<"PUZZLE #"<<t<<endl;
	for(int i=0;i<5;++i){
		for(int j=0;j<6;j++) {
			cout<<GetBit(result[i],j);
			if(j<5)
			  cout<<" ";
		}
		cout<<endl;
	}	
}
int main()
{
	int T;
	cin>>T;
	for(int t=1;t<=T;++t){
		for(int i=0;i<5;++i){
			for (int j=0;j<6;++j){
				int s;
				cin>>s;
				SetBit(oriLights[i],j,s);	
			}
		}
		for(int n=0;n<64;++n){
			int switchs=n;
			memcpy(lights,oriLights,sizeof(oriLights));
			for(int i=0;i<5;++i){
				result[i]=switchs;
				for(int j=0;j<6;j++){
				   if(GetBit(switchs,j)){
				   	if(j>0)
				   	    FlipBit(lights[i],j);
				   	FlipBit(lights[i],j);
				   	if(j<5)
				   		FlipBit(lights[i],j+1); 
				   }
				}
				if(i<4)
				  lights[i+1]^=switchs;
				switchs= lights[i];
			}
			if(lights[4]==0){
				OutputResult(t,result);
				break; 
			}
		}
	}
	return 0;
}
