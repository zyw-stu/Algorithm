#include <cstdio> 
#include <iostream>
#include <string>
#include <vector> 
#include <algorithm>
#include <cctype>
#include <cstring>
using namespace std;
typedef struct dic {
	string s;
	int fre;
	bool operator < (const dic&d) const {
		if (d.fre != fre)
			return d.fre < fre;
		else
			return s<d.s;
	}
}dic, * Pd;
int main()
{
	char s[10000];
	string line;
	vector<dic> v;//存放分割后的原始数据 
	while (getline(cin,line))
	{
		if(line.empty()) break;
		int i;
		for(i=0;i<line.size()-1;i++)
		{
		    	if(line[i]=='\''&&line[i+1]=='s')
		    	{
		    		line[i]=' ';
					line[i+1]=' ';
				}
				if(line[i]=='s'&&line[i+1]=='\'')
				{
					line[i]=' ';
					line[i+1]=' ';
				}	
		}
		strcpy(s,line.c_str());
		char c[] = " ,./?:;\\/<>'|[]{}+=-_()*&^%$#@!~	‘’“”；\"";
		
		char* r = strtok(s, c);
		while (r != NULL) {
			string str;
			dic d;
			str = r;
			transform(str.begin(), str.end(), str.begin(), ::tolower);//转换为小写字母 
		
			d.s=str;	d.fre=1;
			v.push_back(d);		
			r = strtok(NULL, c);
		}
	}//得到了已经分割处理后的容器V
	vector<dic> od;//存放去重后的数据 
		vector<dic>::iterator it; vector<dic>::iterator p;
		for (it = v.begin(); it != v.end(); it++)
		{
			if (it->fre == 0) continue;
			else {
				for (p = it + 1; p != v.end(); p++)
				{
					if (p->fre != 0)
					{
						if (p->s == it->s)
						{
							p->fre = 0;
							it->fre++;
						}
					}
				}
				od.push_back(*it);
			}
		}
		sort(od.begin(), od.end());
		vector<dic>::iterator IT;
		for (IT = od.begin(); IT != od.end(); IT++)
		{
			cout << IT->s << endl;
		}
	return 0;
}
